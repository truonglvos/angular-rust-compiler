//! Variable Optimization Phase
//!
//! Corresponds to packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts
//! Optimize variables declared and used in the IR.

use crate::output::output_ast::{Expression, Statement};
use crate::template::pipeline::ir;
use crate::template::pipeline::ir::enums::{OpKind, CompatibilityMode, VariableFlags};
use crate::template::pipeline::ir::expression::{is_ir_expression, as_ir_expression, transform_expressions_in_op, visit_expressions_in_op, VisitorContextFlag};
use crate::template::pipeline::ir::handle::XrefId;
use crate::template::pipeline::ir::ops::shared::{VariableOp, create_statement_op};
use crate::template::pipeline::ir::operations::OpList;
use crate::template::pipeline::src::compilation::{CompilationJob, CompilationUnit};
use std::collections::{HashMap, HashSet};
use bitflags::bitflags;

bitflags! {
    /// A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates
    /// how that expression can be optimized in relation to other expressions or instructions.
    ///
    /// `Fence`s are a bitfield, so multiple flags may be set on a single expression.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct Fence: u8 {
        /// Empty flag (no fence exists).
        const NONE = 0b000;

        /// A context read fence, meaning that the expression in question reads from the "current view"
        /// context of the runtime.
        const VIEW_CONTEXT_READ = 0b001;

        /// A context write fence, meaning that the expression in question writes to the "current view"
        /// context of the runtime.
        ///
        /// Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which
        /// change the view context do so based on the current one.
        const VIEW_CONTEXT_WRITE = 0b010;

        /// Indicates that a call is required for its side-effects, even if nothing reads its result.
        ///
        /// This is also true of `ViewContextWrite` operations **if** they are followed by a
        /// `ViewContextRead`.
        const SIDE_EFFECTFUL = 0b100;
    }
}

/// Summary data collected for each `Op` in a list.
///
/// Tracking this data per operation allows the optimizer to process operations at a higher level
/// than always scanning expressions.
#[derive(Clone)]
struct OpInfo {
    /// A set of variables referenced by expressions in this operation.
    variables_used: HashSet<XrefId>,

    /// Flags indicating any `Fence`s present for this operation.
    fences: Fence,
}

/// Optimize variables declared and used in the IR.
///
/// Variables are eagerly generated by pipeline stages for all possible values that could be
/// referenced. This stage processes the list of declared variables and all variable usages,
/// and optimizes where possible. It performs 3 main optimizations:
///
///   * It transforms variable declarations to side effectful expressions when the
///     variable is not used, but its initializer has global effects which other
///     operations rely upon.
///   * It removes variable declarations if those variables are not referenced and
///     either they do not have global effects, or nothing relies on them.
///   * It inlines variable declarations when those variables are only used once
///     and the inlining is semantically safe.
///
/// To guarantee correctness, analysis of "fences" in the instruction lists is used to determine
/// which optimizations are safe to perform.
pub fn optimize_variables(job: &mut dyn CompilationJob) {
    // Process all units (root and views)
    // Use unsafe to work around borrow checker limitations
    unsafe {
        let job_ptr = job as *mut dyn CompilationJob;
        let component_job_ptr = job_ptr as *mut crate::template::pipeline::src::compilation::ComponentCompilationJob;
        let component_job = &mut *component_job_ptr;
        let compatibility = job.compatibility();
        
        // Process root
        inline_always_inline_variables_create(component_job.root.create_mut());
        inline_always_inline_variables_update(component_job.root.update_mut());
        
        for op in component_job.root.create_mut().iter_mut() {
            process_handler_ops_create(op, |handler_ops| {
                inline_always_inline_variables_update(handler_ops);
            });
        }
        
        optimize_variables_in_op_list_create(component_job.root.create_mut(), compatibility);
        optimize_variables_in_op_list_update(component_job.root.update_mut(), compatibility);
        
        for op in component_job.root.create_mut().iter_mut() {
            process_handler_ops_create(op, |handler_ops| {
                optimize_variables_in_op_list_update(handler_ops, compatibility);
            });
        }
        
        // Process views
        for (_, view) in component_job.views.iter_mut() {
            inline_always_inline_variables_create(view.create_mut());
            inline_always_inline_variables_update(view.update_mut());
            
            for op in view.create_mut().iter_mut() {
                process_handler_ops_create(op, |handler_ops| {
                    inline_always_inline_variables_update(handler_ops);
                });
            }
            
            optimize_variables_in_op_list_create(view.create_mut(), compatibility);
            optimize_variables_in_op_list_update(view.update_mut(), compatibility);
            
            for op in view.create_mut().iter_mut() {
                process_handler_ops_create(op, |handler_ops| {
                    optimize_variables_in_op_list_update(handler_ops, compatibility);
                });
            }
        }
    }
}


/// Helper to process handler ops in a create operation
fn process_handler_ops_create<F>(op: &mut Box<dyn ir::CreateOp + Send + Sync>, mut f: F)
where
    F: FnMut(&mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>),
{
    match op.kind() {
        OpKind::Listener | OpKind::Animation | OpKind::AnimationListener | OpKind::TwoWayListener => {
            unsafe {
                use crate::template::pipeline::ir::ops::create::{ListenerOp, AnimationListenerOp, TwoWayListenerOp};
                let op_ptr = op.as_mut() as *mut dyn ir::CreateOp;
                match op.kind() {
                    OpKind::Listener => {
                        let listener_ptr = op_ptr as *mut ListenerOp;
                        f(&mut (*listener_ptr).handler_ops);
                    }
                    OpKind::AnimationListener => {
                        let anim_listener_ptr = op_ptr as *mut AnimationListenerOp;
                        f(&mut (*anim_listener_ptr).handler_ops);
                    }
                    OpKind::TwoWayListener => {
                        let two_way_ptr = op_ptr as *mut TwoWayListenerOp;
                        f(&mut (*two_way_ptr).handler_ops);
                    }
                    _ => {}
                }
            }
        }
        OpKind::RepeaterCreate => {
            unsafe {
                use crate::template::pipeline::ir::ops::create::RepeaterCreateOp;
                let op_ptr = op.as_mut() as *mut dyn ir::CreateOp;
                let repeater_ptr = op_ptr as *mut RepeaterCreateOp;
                if let Some(ref mut track_by_ops) = (*repeater_ptr).track_by_ops {
                    f(track_by_ops);
                }
            }
        }
        _ => {}
    }
}

/// Inline variables marked with AlwaysInline flag for CreateOp list.
fn inline_always_inline_variables_create(ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>) {
    inline_always_inline_variables_impl_create(ops);
}

/// Inline variables marked with AlwaysInline flag for UpdateOp list.
fn inline_always_inline_variables_update(ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>) {
    inline_always_inline_variables_impl_update(ops);
}

/// Implementation for CreateOp list
fn inline_always_inline_variables_impl_create(ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>) {
    let mut vars: HashMap<XrefId, usize> = HashMap::new(); // xref -> index
    
    // First pass: collect AlwaysInline variables
    for (index, op) in ops.iter_mut().enumerate() {
        if op.kind() == OpKind::Variable {
            unsafe {
                // Get VariableOp - need to handle both CreateOp and UpdateOp cases
                let op_ptr = op.as_mut() as *mut dyn ir::Op;
                
                // Cast to VariableOp<Box<dyn CreateOp>>
                let var_op_ptr = op_ptr as *mut VariableOp<Box<dyn ir::CreateOp + Send + Sync>>;
                let var_op = &*var_op_ptr;
                
                if var_op.flags.contains(VariableFlags::ALWAYS_INLINE) {
                    // Check that the variable doesn't have context-sensitive expressions
                    visit_expressions_in_op(
                        op.as_mut(),
                        &mut |expr: &Expression, _flags| {
                            if is_ir_expression(expr) {
                                if let Some(ir_expr) = as_ir_expression(expr) {
                                    if fences_for_ir_expression(&ir_expr) != Fence::NONE {
                                        panic!("AssertionError: A context-sensitive variable was marked AlwaysInline");
                                    }
                                }
                            }
                        },
                    );
                    
                    vars.insert(var_op.xref, index);
                }
            }
        }
    }
    
    // Collect initializers before iterating to avoid borrow conflicts
    let mut initializers: HashMap<XrefId, Expression> = HashMap::new();
    for (xref, &index) in &vars {
        unsafe {
            let ops_ptr = ops as *const OpList<Box<dyn ir::CreateOp + Send + Sync>>;
            let var_op = (*ops_ptr).get(index).unwrap();
            let op_ptr = var_op.as_ref() as *const dyn ir::Op;
            let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::CreateOp + Send + Sync>>;
            let var_op = &*var_op_ptr;
            initializers.insert(*xref, (*var_op.initializer).clone());
        }
    }
    
    // Second pass: inline the variables
    for op in ops.iter_mut() {
        transform_expressions_in_op(
            op.as_mut(),
            &mut |expr: Expression, _flags| {
                if is_ir_expression(&expr) {
                    if let Some(ir_expr) = as_ir_expression(&expr) {
                        if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                            if let Some(initializer) = initializers.get(&read_var.xref) {
                                return initializer.clone();
                            }
                        }
                    }
                }
                expr
            },
            VisitorContextFlag::NONE,
        );
    }
    
    // Third pass: remove the AlwaysInline variable declarations
    // Remove in reverse order to maintain correct indices
    let mut indices_to_remove: Vec<usize> = vars.values().copied().collect();
    indices_to_remove.sort();
    indices_to_remove.reverse();
    
    for &index in &indices_to_remove {
        ops.remove_at(index);
    }
}

/// Implementation for UpdateOp list
fn inline_always_inline_variables_impl_update(ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>) {
    let mut vars: HashMap<XrefId, usize> = HashMap::new(); // xref -> index
    
    // First pass: collect AlwaysInline variables
    for (index, op) in ops.iter_mut().enumerate() {
        if op.kind() == OpKind::Variable {
            unsafe {
                // Get VariableOp - handle UpdateOp case
                let op_ptr = op.as_mut() as *mut dyn ir::Op;
                
                // Cast to VariableOp<Box<dyn UpdateOp>>
                let var_op_ptr = op_ptr as *mut VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>;
                let var_op = &*var_op_ptr;
                
                if var_op.flags.contains(VariableFlags::ALWAYS_INLINE) {
                    // Check that the variable doesn't have context-sensitive expressions
                    visit_expressions_in_op(
                        op.as_mut(),
                        &mut |expr: &Expression, _flags| {
                            if is_ir_expression(expr) {
                                if let Some(ir_expr) = as_ir_expression(expr) {
                                    if fences_for_ir_expression(&ir_expr) != Fence::NONE {
                                        panic!("AssertionError: A context-sensitive variable was marked AlwaysInline");
                                    }
                                }
                            }
                        },
                    );
                    
                    vars.insert(var_op.xref, index);
                }
            }
        }
    }
    
    // Collect initializers before iterating to avoid borrow conflicts
    let mut initializers: HashMap<XrefId, Expression> = HashMap::new();
    for (xref, &index) in &vars {
        unsafe {
            let ops_ptr = ops as *const OpList<Box<dyn ir::UpdateOp + Send + Sync>>;
            let var_op = (*ops_ptr).get(index).unwrap();
            let op_ptr = var_op.as_ref() as *const dyn ir::Op;
            let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>;
            let var_op = &*var_op_ptr;
            initializers.insert(*xref, (*var_op.initializer).clone());
        }
    }
    
    // Second pass: inline the variables
    for op in ops.iter_mut() {
        transform_expressions_in_op(
            op.as_mut(),
            &mut |expr: Expression, _flags| {
                if is_ir_expression(&expr) {
                    if let Some(ir_expr) = as_ir_expression(&expr) {
                        if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                            if let Some(initializer) = initializers.get(&read_var.xref) {
                                return initializer.clone();
                            }
                        }
                    }
                }
                expr
            },
            VisitorContextFlag::NONE,
        );
    }
    
    // Third pass: remove the AlwaysInline variable declarations
    // Remove in reverse order to maintain correct indices
    let mut indices_to_remove: Vec<usize> = vars.values().copied().collect();
    indices_to_remove.sort();
    indices_to_remove.reverse();
    
    for &index in &indices_to_remove {
        ops.remove_at(index);
    }
}

/// Process a list of create operations and optimize variables within that list.
fn optimize_variables_in_op_list_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    // Convert to OpList<Box<dyn Op>> for processing
    // Note: This approach requires collecting indices and processing separately
    // We'll need to duplicate the logic or use a different approach
    // For now, let's implement separately for CreateOp and UpdateOp
    optimize_variables_in_op_list_impl_create(ops, compatibility);
}

/// Process a list of update operations and optimize variables within that list.
fn optimize_variables_in_op_list_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    optimize_variables_in_op_list_impl_update(ops, compatibility);
}

/// Implementation for CreateOp list
/// Since we can't easily convert between OpList types, we'll duplicate the logic
fn optimize_variables_in_op_list_impl_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    // Implementation similar to optimize_variables_in_op_list_impl_update
    // but for CreateOp. For now, we'll just process as Op trait objects
    optimize_variables_in_op_list_impl_update(
        unsafe { std::mem::transmute(ops) },
        compatibility,
    );
}

/// Implementation for UpdateOp list
fn optimize_variables_in_op_list_impl_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    // Directly implement for UpdateOp list
    
    // TODO: Process ops_as_op, then convert back
    // For now, let's implement directly for UpdateOp
    optimize_variables_in_op_list_impl_update_direct(ops, compatibility);
}

/// Direct implementation for UpdateOp list
fn optimize_variables_in_op_list_impl_update_direct(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    let mut var_decls: HashMap<XrefId, usize> = HashMap::new(); // xref -> index
    let mut var_usages: HashMap<XrefId, usize> = HashMap::new(); // xref -> usage count
    let mut var_remote_usages: HashSet<XrefId> = HashSet::new();
    let mut op_map: HashMap<usize, OpInfo> = HashMap::new(); // index -> OpInfo
    
    // First pass: collect variable declarations and build op info
    for (index, op) in ops.iter().enumerate() {
        if op.kind() == OpKind::Variable {
            unsafe {
                let op_ptr = op.as_ref() as *const dyn ir::Op;
                let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::Op + Send + Sync>>;
                let var_op = &*var_op_ptr;
                
                if var_decls.contains_key(&var_op.xref) || var_usages.contains_key(&var_op.xref) {
                    panic!("Should not see two declarations of the same variable: {}", var_op.xref.as_usize());
                }
                
                var_decls.insert(var_op.xref, index);
                var_usages.insert(var_op.xref, 0);
            }
        }
        
        op_map.insert(index, collect_op_info(op.as_ref()));
        count_variable_usages(op.as_ref(), &mut var_usages, &mut var_remote_usages);
    }
    
    // Second pass: remove unused variables (iterate in reverse)
    let mut context_is_used = false;
    let mut indices_to_remove: Vec<usize> = Vec::new();
    let mut indices_to_replace: Vec<(usize, Statement)> = Vec::new(); // index -> Statement
    
    for index in (0..ops.len()).rev() {
        let op = ops.get(index).unwrap();
        
        if op.kind() == OpKind::Variable {
            unsafe {
                let op_ptr = op.as_ref() as *const dyn ir::Op;
                let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::Op + Send + Sync>>;
                let var_op = &*var_op_ptr;
                
                let usage_count = var_usages.get(&var_op.xref).copied().unwrap_or(0);
                
                if usage_count == 0 {
                    let op_info = op_map.get(&index).unwrap();
                    
                    // Check if we need to keep the initializer as a side-effectful statement
                    if (context_is_used && op_info.fences.contains(Fence::VIEW_CONTEXT_WRITE))
                        || op_info.fences.contains(Fence::SIDE_EFFECTFUL)
                    {
                        // Replace with statement op
                        let stmt = (*var_op.initializer).clone().to_stmt();
                        indices_to_replace.push((index, stmt));
                    } else {
                        // Safe to remove entirely
                        indices_to_remove.push(index);
                        uncount_variable_usages(op.as_ref(), &mut var_usages);
                    }
                    
                    op_map.remove(&index);
                    var_decls.remove(&var_op.xref);
                    var_usages.remove(&var_op.xref);
                    continue;
                }
            }
        }
        
        // Track context usage
        if let Some(op_info) = op_map.get(&index) {
            if op_info.fences.contains(Fence::VIEW_CONTEXT_READ) {
                context_is_used = true;
            }
        }
    }
    
    // Apply replacements and removals
    for (index, stmt) in indices_to_replace {
        // Create StatementOp from statement
        let stmt_op = create_statement_op::<Box<dyn ir::UpdateOp + Send + Sync>>(Box::new(stmt));
        let op_info = op_map.remove(&index).unwrap();
        
        // Replace the VariableOp with StatementOp
        // StatementOp implements UpdateOp, so we can use it directly
        ops.replace_at(index, Box::new(stmt_op));
        op_map.insert(index, op_info);
    }
    
    for &index in indices_to_remove.iter() {
        ops.remove_at(index);
        // Update indices in op_map for remaining ops
        let mut new_op_map = HashMap::new();
        for (old_idx, info) in op_map {
            if old_idx > index {
                new_op_map.insert(old_idx - 1, info);
            } else if old_idx != index {
                new_op_map.insert(old_idx, info);
            }
        }
        op_map = new_op_map;
    }
    
    // Third pass: inline variables with exactly one usage
    let mut to_inline: Vec<XrefId> = Vec::new();
    
    for (xref, &count) in &var_usages {
        let &decl_index = var_decls.get(xref).unwrap();
        let decl_op = ops.get(decl_index).unwrap();
        
        unsafe {
            let op_ptr = decl_op.as_ref() as *const dyn ir::Op;
            let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::Op + Send + Sync>>;
            let var_op = &*var_op_ptr;
            
            let is_always_inline = var_op.flags.contains(VariableFlags::ALWAYS_INLINE);
            
            if count != 1 || is_always_inline {
                continue;
            }
            
            if var_remote_usages.contains(xref) {
                continue;
            }
            
            to_inline.push(*xref);
        }
    }
    
    // Process inlining candidates
    while let Some(candidate) = to_inline.pop() {
        let decl_index = *var_decls.get(&candidate).unwrap();
        let decl_op = ops.get(decl_index).unwrap();
        
        unsafe {
            let op_ptr = decl_op.as_ref() as *const dyn ir::Op;
            let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::Op + Send + Sync>>;
            let var_op = &*var_op_ptr;
            
            let var_info = op_map.get(&decl_index).unwrap();
            let is_always_inline = var_op.flags.contains(VariableFlags::ALWAYS_INLINE);
            
            if is_always_inline {
                panic!("AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.");
            }
            
            // Find the usage site (scan forward from declaration)
            let mut inlined = false;
            for target_index in (decl_index + 1)..ops.len() {
                let target_op = ops.get(target_index).unwrap();
                let target_info_ref = op_map.get(&target_index).unwrap();
                
                // Check if variable is used in this operation
                if target_info_ref.variables_used.contains(&candidate) {
                    // Check conservative inlining mode
                    if compatibility == CompatibilityMode::TemplateDefinitionBuilder {
                        if !allow_conservative_inlining(var_op, target_op.as_ref()) {
                            break;
                        }
                    }
                    
                    // Try to inline
                    let target_op_mut = ops.get_mut(target_index).unwrap();
                    // Cast Box<dyn UpdateOp> to Box<dyn Op> for try_inline_variable_initializer
                    // UpdateOp is a subtrait of Op, so this is safe
                    let target_op_as_op: &mut Box<dyn ir::Op + Send + Sync> = unsafe {
                        let op_ptr = target_op_mut as *mut Box<dyn ir::UpdateOp + Send + Sync>;
                        &mut *(op_ptr as *mut Box<dyn ir::Op + Send + Sync>)
                    };
                    if try_inline_variable_initializer(
                        candidate,
                        (*var_op.initializer).clone(),
                        target_op_as_op,
                        var_info.fences.clone(),
                    ) {
                        // Update tracking structures - clone target_info since it's a reference
                        let mut new_target_info = OpInfo {
                            variables_used: target_info_ref.variables_used.clone(),
                            fences: target_info_ref.fences,
                        };
                        new_target_info.variables_used.remove(&candidate);
                        
                        // Add variables from initializer
                        for &var_xref in &var_info.variables_used {
                            new_target_info.variables_used.insert(var_xref);
                        }
                        
                        // Merge fences
                        new_target_info.fences |= var_info.fences.clone();
                        
                        op_map.insert(target_index, new_target_info);
                        
                        // Delete tracking info
                        var_decls.remove(&candidate);
                        var_usages.remove(&candidate);
                        let _ = op_map.remove(&decl_index);
                        
                        // Remove the declaration
                        ops.remove_at(decl_index);
                        
                        // Update indices
                        let mut new_op_map = HashMap::new();
                        for (old_idx, info) in op_map {
                            if old_idx > decl_index {
                                new_op_map.insert(old_idx - 1, info);
                            } else if old_idx != decl_index {
                                new_op_map.insert(old_idx, info);
                            }
                        }
                        op_map = new_op_map;
                        
                        inlined = true;
                        break;
                    } else {
                        break;
                    }
                }
                
                // Check if it's safe to inline past this operation
                if !safe_to_inline_past_fences(target_info_ref.fences, var_info.fences) {
                    break;
                }
            }
            
            if !inlined {
                // Couldn't inline this variable, skip it
                continue;
            }
        }
    }
}

/// Given an `ir.Expression`, returns the `Fence` flags for that expression type.
fn fences_for_ir_expression(expr: &ir::IRExpression) -> Fence {
    match expr {
        ir::IRExpression::NextContext(_) => {
            Fence::VIEW_CONTEXT_READ | Fence::VIEW_CONTEXT_WRITE
        }
        ir::IRExpression::RestoreView(_) => {
            Fence::VIEW_CONTEXT_READ | Fence::VIEW_CONTEXT_WRITE | Fence::SIDE_EFFECTFUL
        }
        ir::IRExpression::StoreLet(_) => {
            Fence::SIDE_EFFECTFUL
        }
        ir::IRExpression::Reference(_) | ir::IRExpression::ContextLetReference(_) => {
            Fence::VIEW_CONTEXT_READ
        }
        _ => Fence::NONE,
    }
}

/// Helper to visit expressions in an operation without needing mutable reference
/// Uses recursive pattern to traverse all expressions
fn visit_expressions_in_op_readonly(
    op: &dyn ir::Op,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    // Match on op.kind() and extract expressions from concrete types
    use crate::template::pipeline::ir::ops::update::*;
    use crate::template::pipeline::ir::ops::shared::*;
    use crate::template::pipeline::ir::ops::create::*;
    
    match op.kind() {
        OpKind::Variable => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let var_op_ptr = op_ptr as *const VariableOp<Box<dyn ir::Op + Send + Sync>>;
                let var_op = &*var_op_ptr;
                visit_expressions_recursive(&var_op.initializer, visitor, flags);
            }
        }
        OpKind::Binding => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let binding_ptr = op_ptr as *const BindingOp;
                let binding = &*binding_ptr;
                match &binding.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags);
                    }
                    BindingExpression::Interpolation(interp) => {
                        for expr in &interp.expressions {
                            visit_expressions_recursive(expr, visitor, flags);
                        }
                    }
                }
            }
        }
        OpKind::Property | OpKind::DomProperty | OpKind::Attribute | OpKind::Control => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                match op.kind() {
                    OpKind::Property => {
                        let prop_ptr = op_ptr as *const PropertyOp;
                        let prop = &*prop_ptr;
                        match &prop.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                        if let Some(ref sanitizer) = prop.sanitizer {
                            visit_expressions_recursive(sanitizer, visitor, flags);
                        }
                    }
                    OpKind::DomProperty => {
                        let dom_prop_ptr = op_ptr as *const crate::template::pipeline::ir::ops::host::DomPropertyOp;
                        let dom_prop = &*dom_prop_ptr;
                        match &dom_prop.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                        if let Some(ref sanitizer) = dom_prop.sanitizer {
                            visit_expressions_recursive(sanitizer, visitor, flags);
                        }
                    }
                    OpKind::Attribute => {
                        let attr_ptr = op_ptr as *const AttributeOp;
                        let attr = &*attr_ptr;
                        match &attr.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                        if let Some(ref sanitizer) = attr.sanitizer {
                            visit_expressions_recursive(sanitizer, visitor, flags);
                        }
                    }
                    OpKind::Control => {
                        let control_ptr = op_ptr as *const ControlOp;
                        let control = &*control_ptr;
                        match &control.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                        if let Some(ref sanitizer) = control.sanitizer {
                            visit_expressions_recursive(sanitizer, visitor, flags);
                        }
                    }
                    _ => {}
                }
            }
        }
        OpKind::StyleProp | OpKind::ClassProp | OpKind::StyleMap | OpKind::ClassMap => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                match op.kind() {
                    OpKind::StyleProp => {
                        let style_prop_ptr = op_ptr as *const StylePropOp;
                        let style_prop = &*style_prop_ptr;
                        match &style_prop.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                    }
                    OpKind::ClassProp => {
                        let class_prop_ptr = op_ptr as *const ClassPropOp;
                        let class_prop = &*class_prop_ptr;
                        visit_expressions_recursive(&class_prop.expression, visitor, flags);
                    }
                    OpKind::StyleMap => {
                        let style_map_ptr = op_ptr as *const StyleMapOp;
                        let style_map = &*style_map_ptr;
                        match &style_map.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                    }
                    OpKind::ClassMap => {
                        let class_map_ptr = op_ptr as *const ClassMapOp;
                        let class_map = &*class_map_ptr;
                        match &class_map.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        OpKind::TwoWayProperty => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let two_way_ptr = op_ptr as *const TwoWayPropertyOp;
                let two_way = &*two_way_ptr;
                visit_expressions_recursive(&two_way.expression, visitor, flags);
                if let Some(ref sanitizer) = two_way.sanitizer {
                    visit_expressions_recursive(sanitizer, visitor, flags);
                }
            }
        }
        OpKind::InterpolateText => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let interp_ptr = op_ptr as *const InterpolateTextOp;
                let interp = &*interp_ptr;
                for expr in &interp.interpolation.expressions {
                    visit_expressions_recursive(expr, visitor, flags);
                }
            }
        }
        OpKind::Conditional => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let cond_ptr = op_ptr as *const ConditionalOp;
                let cond = &*cond_ptr;
                if let Some(ref test) = cond.test {
                    visit_expressions_recursive(test, visitor, flags);
                }
                for case in &cond.conditions {
                    if let Some(ref expr) = case.expr {
                        visit_expressions_recursive(expr, visitor, flags);
                    }
                }
                if let Some(ref processed) = cond.processed {
                    visit_expressions_recursive(processed, visitor, flags);
                }
                if let Some(ref context_value) = cond.context_value {
                    visit_expressions_recursive(context_value, visitor, flags);
                }
            }
        }
        OpKind::Repeater => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let repeater_ptr = op_ptr as *const RepeaterOp;
                let repeater = &*repeater_ptr;
                visit_expressions_recursive(&repeater.collection, visitor, flags);
            }
        }
        OpKind::Statement => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let stmt_ptr = op_ptr as *const StatementOp<Box<dyn ir::Op + Send + Sync>>;
                let stmt = &*stmt_ptr;
                visit_expressions_in_statement(&stmt.statement, visitor, flags);
            }
        }
        OpKind::StoreLet => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let store_let_ptr = op_ptr as *const StoreLetOp;
                let store_let = &*store_let_ptr;
                visit_expressions_recursive(&store_let.value, visitor, flags);
            }
        }
        OpKind::I18nExpression => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let i18n_expr_ptr = op_ptr as *const I18nExpressionOp;
                let i18n_expr = &*i18n_expr_ptr;
                visit_expressions_recursive(&i18n_expr.expression, visitor, flags);
            }
        }
        OpKind::DeferWhen => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                let defer_when_ptr = op_ptr as *const DeferWhenOp;
                let defer_when = &*defer_when_ptr;
                visit_expressions_recursive(&defer_when.expr, visitor, flags);
            }
        }
        OpKind::AnimationBinding | OpKind::AnimationString => {
            unsafe {
                let op_ptr = op as *const dyn ir::Op;
                match op.kind() {
                    OpKind::AnimationBinding => {
                        let anim_binding_ptr = op_ptr as *const AnimationBindingOp;
                        let anim_binding = &*anim_binding_ptr;
                        match &anim_binding.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                    }
                    OpKind::AnimationString => {
                        let anim_string_ptr = op_ptr as *const AnimationStringOp;
                        let anim_string = &*anim_string_ptr;
                        match &anim_string.expression {
                            BindingExpression::Expression(expr) => {
                                visit_expressions_recursive(expr, visitor, flags);
                            }
                            BindingExpression::Interpolation(interp) => {
                                for expr in &interp.expressions {
                                    visit_expressions_recursive(expr, visitor, flags);
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        _ => {
            // For other operations, no expressions to visit
        }
    }
}

/// Recursively visit all expressions in an expression
fn visit_expressions_recursive(
    expr: &Expression,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    // Visit the expression itself
    visitor(expr, flags);
    
    // Recursively visit nested expressions
    use crate::output::output_ast::Expression as OutputExpr;
    match expr {
        OutputExpr::BinaryOp(bin) => {
            visit_expressions_recursive(&bin.lhs, visitor, flags);
            visit_expressions_recursive(&bin.rhs, visitor, flags);
        }
        OutputExpr::Unary(un) => {
            visit_expressions_recursive(&un.expr, visitor, flags);
        }
        OutputExpr::ReadProp(prop) => {
            visit_expressions_recursive(&prop.receiver, visitor, flags);
        }
        OutputExpr::ReadKey(key) => {
            visit_expressions_recursive(&key.receiver, visitor, flags);
            visit_expressions_recursive(&key.index, visitor, flags);
        }
        OutputExpr::InvokeFn(invoke) => {
            visit_expressions_recursive(&invoke.fn_, visitor, flags);
            for arg in &invoke.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        OutputExpr::LiteralArray(arr) => {
            for entry in &arr.entries {
                visit_expressions_recursive(entry, visitor, flags);
            }
        }
        OutputExpr::LiteralMap(map) => {
            for entry in &map.entries {
                visit_expressions_recursive(&entry.value, visitor, flags);
            }
        }
        OutputExpr::Conditional(cond) => {
            visit_expressions_recursive(&cond.condition, visitor, flags);
            visit_expressions_recursive(&cond.true_case, visitor, flags);
            if let Some(ref false_case) = cond.false_case {
                visit_expressions_recursive(false_case, visitor, flags);
            }
        }
        OutputExpr::SafePropertyRead(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
        }
        OutputExpr::SafeKeyedRead(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
            visit_expressions_recursive(&ir_expr.index, visitor, flags);
        }
        OutputExpr::SafeInvokeFunction(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
            for arg in &ir_expr.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        OutputExpr::SafeTernary(ir_expr) => {
            visit_expressions_recursive(&ir_expr.guard, visitor, flags);
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::PipeBinding(ir_expr) => {
            for arg in &ir_expr.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        OutputExpr::PipeBindingVariadic(ir_expr) => {
            visit_expressions_recursive(&ir_expr.args, visitor, flags);
        }
        OutputExpr::AssignTemporary(ir_expr) => {
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::StoreLet(ir_expr) => {
            visit_expressions_recursive(&ir_expr.value, visitor, flags);
        }
        OutputExpr::ConditionalCase(ir_expr) => {
            if let Some(ref expr) = ir_expr.expr {
                visit_expressions_recursive(expr, visitor, flags);
            }
        }
        _ => {
            // No nested expressions or already handled
        }
    }
}

/// Visit expressions in a statement
fn visit_expressions_in_statement(
    stmt: &Statement,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    use crate::output::output_ast::Statement;
    match stmt {
        Statement::Expression(expr_stmt) => {
            visit_expressions_recursive(&expr_stmt.expr, visitor, flags);
        }
        Statement::Return(return_stmt) => {
            visit_expressions_recursive(&return_stmt.value, visitor, flags);
        }
        Statement::DeclareVar(declare_var) => {
            if let Some(ref value) = declare_var.value {
                visit_expressions_recursive(value, visitor, flags);
            }
        }
        Statement::IfStmt(if_stmt) => {
            visit_expressions_recursive(&if_stmt.condition, visitor, flags);
            for case_stmt in &if_stmt.true_case {
                visit_expressions_in_statement(case_stmt, visitor, flags);
            }
            for case_stmt in &if_stmt.false_case {
                visit_expressions_in_statement(case_stmt, visitor, flags);
            }
        }
        Statement::DeclareFn(declare_fn) => {
            for stmt in &declare_fn.statements {
                visit_expressions_in_statement(stmt, visitor, flags);
            }
        }
    }
}

/// Build the `OpInfo` structure for the given `op`.
fn collect_op_info(op: &dyn ir::Op) -> OpInfo {
    let mut fences = Fence::NONE;
    let mut variables_used = HashSet::new();
    
    // Use read-only visitor to collect info
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, _flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    match ir_expr {
                        ir::IRExpression::ReadVariable(read_var) => {
                            variables_used.insert(read_var.xref);
                        }
                        _ => {
                            fences |= fences_for_ir_expression(&ir_expr);
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
    
    OpInfo {
        variables_used,
        fences,
    }
}

/// Count the number of usages of each variable, being careful to track whether those usages are
/// local or remote.
fn count_variable_usages(
    op: &dyn ir::Op,
    var_usages: &mut HashMap<XrefId, usize>,
    var_remote_usage: &mut HashSet<XrefId>,
) {
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                        if let Some(count) = var_usages.get_mut(&read_var.xref) {
                            *count += 1;
                            
                            if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION) {
                                var_remote_usage.insert(read_var.xref);
                            }
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
}

/// Remove usages of a variable in `op` from the `var_usages` tracking.
fn uncount_variable_usages(
    op: &dyn ir::Op,
    var_usages: &mut HashMap<XrefId, usize>,
) {
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, _flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                        if let Some(count) = var_usages.get_mut(&read_var.xref) {
                            if *count == 0 {
                                panic!(
                                    "Inaccurate variable count: {} - found another read but count is already 0",
                                    read_var.xref.as_usize()
                                );
                            }
                            *count -= 1;
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
}

/// Checks whether it's safe to inline a variable across a particular operation.
fn safe_to_inline_past_fences(fences: Fence, decl_fences: Fence) -> bool {
    if fences.contains(Fence::VIEW_CONTEXT_WRITE) {
        // It's not safe to inline context reads across context writes.
        if decl_fences.contains(Fence::VIEW_CONTEXT_READ) {
            return false;
        }
    } else if fences.contains(Fence::VIEW_CONTEXT_READ) {
        // It's not safe to inline context writes across context reads.
        if decl_fences.contains(Fence::VIEW_CONTEXT_WRITE) {
            return false;
        }
    }
    true
}

/// Attempt to inline the initializer of a variable into a target operation's expressions.
fn try_inline_variable_initializer(
    id: XrefId,
    initializer: Expression,
    target: &mut Box<dyn ir::Op + Send + Sync>,
    decl_fences: Fence,
) -> bool {
    let mut inlined = false;
    let mut inlining_allowed = true;
    
    transform_expressions_in_op(
        target.as_mut(),
        &mut |expr: Expression, flags| {
            if inlined || !inlining_allowed {
                return expr;
            }
            
            if !is_ir_expression(&expr) {
                return expr;
            }
            
            if let Some(ir_expr) = as_ir_expression(&expr) {
                if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION)
                    && decl_fences.contains(Fence::VIEW_CONTEXT_READ)
                {
                    // Cannot inline context-sensitive variables across operation boundaries
                    return expr;
                }
                
                match ir_expr {
                    ir::IRExpression::ReadVariable(read_var) => {
                        if read_var.xref == id {
                            // This is the usage site - inline it
                            inlined = true;
                            return initializer.clone();
                        }
                    }
                    _ => {
                        // Check fences for this expression
                        let expr_fences = fences_for_ir_expression(&ir_expr);
                        inlining_allowed = inlining_allowed && safe_to_inline_past_fences(expr_fences, decl_fences);
                    }
                }
            }
            
            expr
        },
        VisitorContextFlag::NONE,
    );
    
    inlined
}

/// Determines whether inlining of `decl` should be allowed in "conservative" mode.
fn allow_conservative_inlining(
    decl: &VariableOp<Box<dyn ir::Op + Send + Sync>>,
    target: &dyn ir::Op,
) -> bool {
    // TODO: understand exactly how TemplateDefinitionBuilder approaches inlining
    match decl.variable.kind() {
        ir::SemanticVariableKind::Identifier => {
            // Check if initializer is ReadVarExpr with name 'ctx'
            if let Expression::ReadVar(read_var) = decl.initializer.as_ref() {
                if read_var.name == "ctx" {
                    return true;
                }
            }
            false
        }
        ir::SemanticVariableKind::Context => {
            // Context can only be inlined into other variables
            target.kind() == OpKind::Variable
        }
        _ => true,
    }
}

