//! Variable Optimization Phase
//!
//! Corresponds to packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts
//! Optimize variables declared and used in the IR.

use crate::output::output_ast::{Expression, Statement};
use crate::template::pipeline::ir;
use crate::template::pipeline::ir::enums::{
    CompatibilityMode, OpKind, SemanticVariableKind, VariableFlags,
};
use crate::template::pipeline::ir::expression::{
    as_ir_expression, is_ir_expression, transform_expressions_in_op, visit_expressions_in_op,
    VisitorContextFlag,
};
use crate::template::pipeline::ir::handle::XrefId;
use crate::template::pipeline::ir::operations::OpList;
use crate::template::pipeline::ir::ops::shared::{create_statement_op, VariableOp};
use crate::template::pipeline::src::compilation::{CompilationJob, CompilationUnit};
use bitflags::bitflags;
use indexmap::IndexMap;
use std::collections::HashSet;

bitflags! {
    /// A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates
    /// how that expression can be optimized in relation to other expressions or instructions.
    ///
    /// `Fence`s are a bitfield, so multiple flags may be set on a single expression.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct Fence: u8 {
        /// Empty flag (no fence exists).
        const NONE = 0b000;

        /// A context read fence, meaning that the expression in question reads from the "current view"
        /// context of the runtime.
        const VIEW_CONTEXT_READ = 0b001;

        /// A context write fence, meaning that the expression in question writes to the "current view"
        /// context of the runtime.
        ///
        /// Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which
        /// change the view context do so based on the current one.
        const VIEW_CONTEXT_WRITE = 0b010;

        /// Indicates that a call is required for its side-effects, even if nothing reads its result.
        ///
        /// This is also true of `ViewContextWrite` operations **if** they are followed by a
        /// `ViewContextRead`.
        const SIDE_EFFECTFUL = 0b100;
    }
}

/// Summary data collected for each `Op` in a list.
///
/// Tracking this data per operation allows the optimizer to process operations at a higher level
/// than always scanning expressions.
#[derive(Clone)]
struct OpInfo {
    /// A set of variables referenced by expressions in this operation.
    variables_used: HashSet<XrefId>,

    /// Flags indicating any `Fence`s present for this operation.
    fences: Fence,
}

/// Optimize variables declared and used in the IR.
///
/// Variables are eagerly generated by pipeline stages for all possible values that could be
/// referenced. This stage processes the list of declared variables and all variable usages,
/// and optimizes where possible. It performs 3 main optimizations:
///
///   * It transforms variable declarations to side effectful expressions when the
///     variable is not used, but its initializer has global effects which other
///     operations rely upon.
///   * It removes variable declarations if those variables are not referenced and
///     either they do not have global effects, or nothing relies on them.
///   * It inlines variable declarations when those variables are only used once
///     and the inlining is semantically safe.
///
/// To guarantee correctness, analysis of "fences" in the instruction lists is used to determine
/// which optimizations are safe to perform.
pub fn optimize_variables(job: &mut dyn CompilationJob) {
    let compatibility = job.compatibility();
    let component_job = job
        .as_any_mut()
        .downcast_mut::<crate::template::pipeline::src::compilation::ComponentCompilationJob>()
        .expect("Only ComponentCompilationJob is supported");

    // Optimize the root unit
    optimize_unit(&mut component_job.root, compatibility);

    // Optimize each unit
    for view in component_job.views.values_mut() {
        optimize_unit(view, compatibility);
    }
}

/// Helper to process handler ops in a create operation
fn process_handler_ops_create<F>(op: &mut Box<dyn ir::CreateOp + Send + Sync>, mut f: F)
where
    F: FnMut(&mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>),
{
    use crate::template::pipeline::ir::ops::create::{
        AnimationListenerOp, ListenerOp, RepeaterCreateOp, TwoWayListenerOp,
    };

    // Safe downcasting using as_any_mut()
    if let Some(listener) = op.as_any_mut().downcast_mut::<ListenerOp>() {
        f(&mut listener.handler_ops);
    } else if let Some(anim_listener) = op.as_any_mut().downcast_mut::<AnimationListenerOp>() {
        f(&mut anim_listener.handler_ops);
    } else if let Some(two_way) = op.as_any_mut().downcast_mut::<TwoWayListenerOp>() {
        f(&mut two_way.handler_ops);
    } else if let Some(repeater) = op.as_any_mut().downcast_mut::<RepeaterCreateOp>() {
        if let Some(ref mut track_by_ops) = repeater.track_by_ops {
            f(track_by_ops);
        }
    }
}

/// Collect all variable usages that occur in remote contexts (like listener handlers) across
/// both create and update op lists of a unit.
fn collect_remote_usages_for_unit(unit: &dyn CompilationUnit) -> HashSet<XrefId> {
    let mut remote_usages = HashSet::new();
    let mut dummy_usages = IndexMap::new();

    for op in unit.create().iter() {
        count_variable_usages(op.as_ref(), &mut dummy_usages, &mut remote_usages, false);
    }
    for op in unit.update().iter() {
        count_variable_usages(op.as_ref(), &mut dummy_usages, &mut remote_usages, false);
    }
    remote_usages
}

fn optimize_unit(unit: &mut dyn CompilationUnit, compatibility: CompatibilityMode) {
    inline_always_inline_variables_create(unit.create_mut());
    inline_always_inline_variables_update(unit.update_mut());

    // Process handler ops (listeners)
    // First, always-inline in handlers
    for op in unit.create_mut().iter_mut() {
        process_handler_ops_create(op, |handler_ops| {
            inline_always_inline_variables_update(handler_ops);
        });
    }

    // Collect ALL remote usages from the WHOLE unit (including all listeners)
    let remote_usages = collect_remote_usages_for_unit(unit);

    let unit_xref = unit.xref();

    // Optimize main lists
    optimize_variables_in_op_list_create(
        unit.create_mut(),
        compatibility,
        &remote_usages,
        unit_xref,
    );
    optimize_variables_in_op_list_update(
        unit.update_mut(),
        compatibility,
        &remote_usages,
        unit_xref,
    );

    // Optimize listeners
    let empty_remote = HashSet::new();
    for op in unit.create_mut().iter_mut() {
        process_handler_ops_create(op, |handler_ops| {
            optimize_variables_in_op_list_update(
                handler_ops,
                compatibility,
                &empty_remote,
                unit_xref,
            );
        });
    }
}

/// Inline variables marked with AlwaysInline flag for CreateOp list.
fn inline_always_inline_variables_create(ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>) {
    inline_always_inline_variables_impl_create(ops);
}

/// Inline variables marked with AlwaysInline flag for UpdateOp list.
fn inline_always_inline_variables_update(ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>) {
    inline_always_inline_variables_impl_update(ops);
}

/// Implementation for CreateOp list
fn inline_always_inline_variables_impl_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
) {
    let mut vars: IndexMap<XrefId, usize> = IndexMap::new(); // xref -> index

    // First pass: collect AlwaysInline variables
    for (index, op) in ops.iter_mut().enumerate() {
        if op.kind() == OpKind::Variable {
            // Safe downcast and extract info to avoid borrow conflict
            let info = if let Some(var_op) = op
                .as_any()
                .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
            {
                Some((var_op.xref, var_op.flags))
            } else {
                None
            };

            if let Some((xref, flags)) = info {
                if flags.contains(VariableFlags::ALWAYS_INLINE) {
                    // Check context sensitivity
                    visit_expressions_in_op(op.as_mut(), &mut |expr: &Expression, _flags| {
                        if is_ir_expression(expr) {
                            if let Some(ir_expr) = as_ir_expression(expr) {
                                if fences_for_ir_expression(&ir_expr) != Fence::NONE {
                                    panic!("AssertionError: A context-sensitive variable was marked AlwaysInline");
                                }
                            }
                        }
                    });
                    vars.insert(xref, index);
                }
            }
        }
    }

    // Collect initializers
    let mut initializers: IndexMap<XrefId, Expression> = IndexMap::new();
    // We can't iterate ops again while modifying or borrowing.
    // Iterating ops is fine if we just read.
    for index in vars.values() {
        let op = ops.get(*index).unwrap();
        if let Some(var_op) = op
            .as_any()
            .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
        {
            initializers.insert(var_op.xref, (*var_op.initializer).clone());
        }
    }

    // Second pass: inline the variables
    for op in ops.iter_mut() {
        transform_expressions_in_op(
            op.as_mut(),
            &mut |expr: Expression, _flags| {
                if is_ir_expression(&expr) {
                    if let Some(ir_expr) = as_ir_expression(&expr) {
                        if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                            if let Some(initializer) = initializers.get(&read_var.xref) {
                                return initializer.clone();
                            }
                        }
                    }
                }
                expr
            },
            VisitorContextFlag::NONE,
        );
    }

    // Third pass: remove the AlwaysInline variable declarations
    let mut indices_to_remove: Vec<usize> = vars.values().copied().collect();
    indices_to_remove.sort();
    indices_to_remove.reverse();

    for &index in &indices_to_remove {
        ops.remove_at(index);
    }
}

/// Implementation for UpdateOp list
fn inline_always_inline_variables_impl_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
) {
    let mut vars: IndexMap<XrefId, usize> = IndexMap::new();

    // First pass: collect AlwaysInline variables
    for (index, op) in ops.iter_mut().enumerate() {
        if op.kind() == OpKind::Variable {
            let info = if let Some(var_op) = op
                .as_any()
                .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
            {
                Some((var_op.xref, var_op.flags))
            } else {
                None
            };

            if let Some((xref, flags)) = info {
                if flags.contains(VariableFlags::ALWAYS_INLINE) {
                    visit_expressions_in_op(op.as_mut(), &mut |expr: &Expression, _flags| {
                        if is_ir_expression(expr) {
                            if let Some(ir_expr) = as_ir_expression(expr) {
                                if fences_for_ir_expression(&ir_expr) != Fence::NONE {
                                    panic!("AssertionError: A context-sensitive variable was marked AlwaysInline");
                                }
                            }
                        }
                    });
                    vars.insert(xref, index);
                }
            }
        }
    }

    // Collect initializers
    let mut initializers: IndexMap<XrefId, Expression> = IndexMap::new();
    for index in vars.values() {
        let op = ops.get(*index).unwrap();
        if let Some(var_op) = op
            .as_any()
            .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
        {
            initializers.insert(var_op.xref, (*var_op.initializer).clone());
        }
    }

    // Second pass: inline the variables
    for op in ops.iter_mut() {
        transform_expressions_in_op(
            op.as_mut(),
            &mut |expr: Expression, _flags| {
                if is_ir_expression(&expr) {
                    if let Some(ir_expr) = as_ir_expression(&expr) {
                        if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                            if let Some(initializer) = initializers.get(&read_var.xref) {
                                return initializer.clone();
                            }
                        }
                    }
                }
                expr
            },
            VisitorContextFlag::NONE,
        );
    }

    // Third pass: remove the AlwaysInline variable declarations
    let mut indices_to_remove: Vec<usize> = vars.values().copied().collect();
    indices_to_remove.sort();
    indices_to_remove.reverse();

    for &index in &indices_to_remove {
        ops.remove_at(index);
    }
}

/// Process a list of create operations and optimize variables within that list.
pub fn optimize_variables_in_op_list_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
    extra_remote_usages: &HashSet<XrefId>,
    unit_xref: ir::XrefId,
) {
    optimize_variables_in_op_list_impl_create(ops, compatibility, extra_remote_usages, unit_xref);
}

/// Process a list of update operations and optimize variables within that list.
pub fn optimize_variables_in_op_list_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
    extra_remote_usages: &HashSet<XrefId>,
    unit_xref: ir::XrefId,
) {
    optimize_variables_in_op_list_impl_update(ops, compatibility, extra_remote_usages, unit_xref);
}

/// Implementation for CreateOp list (Safe duplication of logic)
fn optimize_variables_in_op_list_impl_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
    extra_remote_usages: &HashSet<XrefId>,
    _unit_xref: ir::XrefId,
) {
    loop {
        let mut did_change = false;

        let mut var_decls: IndexMap<XrefId, usize> = IndexMap::new();
        let mut var_usages: IndexMap<XrefId, usize> = IndexMap::new();
        let mut var_remote_usages: HashSet<XrefId> = extra_remote_usages.clone();
        let mut op_map: IndexMap<usize, OpInfo> = IndexMap::new();

        // First pass
        for (index, op) in ops.iter().enumerate() {
            if op.kind() == OpKind::Variable {
                if let Some(var_op) = op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
                {
                    if var_decls.contains_key(&var_op.xref) || var_usages.contains_key(&var_op.xref)
                    {
                        panic!(
                            "Should not see two declarations of the same variable: {}",
                            var_op.xref.as_usize()
                        );
                    }
                    var_decls.insert(var_op.xref, index);
                    var_usages.insert(var_op.xref, 0);
                }
            }

            op_map.insert(index, collect_op_info(op.as_ref()));
            count_variable_usages(op.as_ref(), &mut var_usages, &mut var_remote_usages, false);

            // Count usages in child ops (handlers)
            if let Some(listener) = op.as_any().downcast_ref::<crate::template::pipeline::ir::ops::create::ListenerOp>() {
                 for handler_op in &listener.handler_ops {
                     count_variable_usages(handler_op.as_ref(), &mut var_usages, &mut var_remote_usages, true);
                 }
            } else if let Some(anim_listener) = op.as_any().downcast_ref::<crate::template::pipeline::ir::ops::create::AnimationListenerOp>() {
                 for handler_op in &anim_listener.handler_ops {
                     count_variable_usages(handler_op.as_ref(), &mut var_usages, &mut var_remote_usages, true);
                 }
            } else if let Some(two_way) = op.as_any().downcast_ref::<crate::template::pipeline::ir::ops::create::TwoWayListenerOp>() {
                 for handler_op in &two_way.handler_ops {
                     count_variable_usages(handler_op.as_ref(), &mut var_usages, &mut var_remote_usages, true);
                 }
            } else if let Some(repeater) = op.as_any().downcast_ref::<crate::template::pipeline::ir::ops::create::RepeaterCreateOp>() {
                 if let Some(ref track_by_ops) = repeater.track_by_ops {
                     for track_op in track_by_ops {
                         count_variable_usages(track_op.as_ref(), &mut var_usages, &mut var_remote_usages, true);
                     }
                 }
            }
        }

        // Second pass
        let mut context_is_used = false;
        let mut indices_to_remove: Vec<usize> = Vec::new();
        let mut indices_to_replace: Vec<(usize, Statement)> = Vec::new();

        for index in (0..ops.len()).rev() {
            let op = ops.get(index).unwrap();

            if op.kind() == OpKind::Variable {
                if let Some(var_op) = op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
                {
                    let usage_count = var_usages.get(&var_op.xref).copied().unwrap_or(0);
                    let is_remote = var_remote_usages.contains(&var_op.xref);

                    if usage_count == 0 && !is_remote {
                        let op_info = op_map.get(&index).unwrap();
                        if (context_is_used && op_info.fences.contains(Fence::VIEW_CONTEXT_WRITE))
                            || op_info.fences.contains(Fence::SIDE_EFFECTFUL)
                        {
                            let stmt = (*var_op.initializer).clone().to_stmt();
                            indices_to_replace.push((index, stmt));
                        } else {
                            indices_to_remove.push(index);
                            uncount_variable_usages(op.as_ref(), &mut var_usages);
                            op_map.swap_remove(&index);
                        }

                        var_decls.shift_remove(&var_op.xref);
                        var_usages.shift_remove(&var_op.xref);
                        // Optimization occurred, so continue loop
                        did_change = true;
                        continue;
                    }
                }
            }

            if let Some(op_info) = op_map.get(&index) {
                if op_info.fences.contains(Fence::VIEW_CONTEXT_READ) {
                    context_is_used = true;
                }
            }
        }

        for (index, stmt) in indices_to_replace {
            let stmt_op =
                create_statement_op::<Box<dyn ir::CreateOp + Send + Sync>>(Box::new(stmt));
            let op_info = op_map.shift_remove(&index).unwrap();
            ops.replace_at(index, Box::new(stmt_op));
            op_map.insert(index, op_info);
            did_change = true;
        }

        for &index in indices_to_remove.iter() {
            ops.remove_at(index);
            let mut new_op_map = IndexMap::new();
            for (old_idx, info) in op_map {
                if old_idx > index {
                    new_op_map.insert(old_idx - 1, info);
                } else if old_idx != index {
                }
            }
            op_map = new_op_map;

            for index_ref in var_decls.values_mut() {
                if *index_ref > index {
                    *index_ref -= 1;
                }
            }
        }

        // Third pass
        let mut to_inline: Vec<XrefId> = Vec::new();
        for (xref, &count) in &var_usages {
            if let Some(&decl_index) = var_decls.get(xref) {
                let decl_op = ops.get(decl_index).unwrap();

                if let Some(var_op) = decl_op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
                {
                    let is_always_inline = var_op.flags.contains(VariableFlags::ALWAYS_INLINE);
                    if count == 1 && !is_always_inline && !var_remote_usages.contains(xref) {
                        to_inline.push(*xref);
                    }
                }
            }
        }

        while let Some(candidate) = to_inline.pop() {
            let decl_index = *var_decls.get(&candidate).unwrap();
            let decl_op = ops.get(decl_index).unwrap();

            let (initializer, is_always_inline, var_kind) = {
                let op = ops.get(decl_index).unwrap();
                if let Some(var_op) = op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
                {
                    (
                        (*var_op.initializer).clone(),
                        var_op.flags.contains(VariableFlags::ALWAYS_INLINE),
                        var_op.variable.kind(),
                    )
                } else {
                    panic!("Expected VariableOp");
                }
            };

            if is_always_inline {
                panic!("AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.");
            }

            let var_info = op_map.get(&decl_index).unwrap().clone();

            for target_index in (decl_index + 1)..ops.len() {
                let target_info_ref = op_map.get(&target_index).unwrap();
                if target_info_ref.variables_used.contains(&candidate) {
                    let mut allowed = true;
                    if compatibility == CompatibilityMode::TemplateDefinitionBuilder {
                        let target_op = ops.get(target_index).unwrap();
                        if !allow_conservative_inlining(&initializer, target_op.as_ref(), var_kind)
                        {
                            allowed = false;
                        }
                    }
                    if !allowed {
                        break;
                    }

                    let target_op_mut = ops.get_mut(target_index).unwrap();
                    if try_inline_variable_initializer(
                        candidate,
                        initializer.clone(),
                        target_op_mut.as_mut(),
                        var_info.fences.clone(),
                    ) {
                        let mut new_target_info = OpInfo {
                            variables_used: target_info_ref.variables_used.clone(),
                            fences: target_info_ref.fences,
                        };
                        new_target_info.variables_used.remove(&candidate);
                        for &var_xref in &var_info.variables_used {
                            new_target_info.variables_used.insert(var_xref);
                        }
                        new_target_info.fences |= var_info.fences.clone();
                        op_map.insert(target_index, new_target_info);

                        var_decls.swap_remove(&candidate);
                        var_usages.swap_remove(&candidate);

                        op_map.shift_remove(&decl_index);
                        ops.remove_at(decl_index);

                        let mut new_op_map = IndexMap::new();
                        for (old_idx, info) in op_map {
                            if old_idx > decl_index {
                                new_op_map.insert(old_idx - 1, info);
                            } else if old_idx != decl_index {
                                new_op_map.insert(old_idx, info);
                            }
                        }
                        op_map = new_op_map;

                        for index_ref in var_decls.values_mut() {
                            if *index_ref > decl_index {
                                *index_ref -= 1;
                            }
                        }

                        did_change = true;
                        break;
                    } else {
                        break;
                    }
                }

                if !safe_to_inline_past_fences(target_info_ref.fences, var_info.fences) {
                    break;
                }
            }
        }

        if !did_change {
            break;
        }
    }
}

/// Implementation for UpdateOp list (Safe duplication)
fn optimize_variables_in_op_list_impl_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
    extra_remote_usages: &HashSet<XrefId>,
    unit_xref: ir::XrefId,
) {
    loop {
        let mut did_change = false;

        let mut var_decls: IndexMap<XrefId, usize> = IndexMap::new();
        let mut var_usages: IndexMap<XrefId, usize> = IndexMap::new();
        let mut var_remote_usages: HashSet<XrefId> = extra_remote_usages.clone();
        let mut op_map: IndexMap<usize, OpInfo> = IndexMap::new();

        // First pass
        for (index, op) in ops.iter().enumerate() {
            if op.kind() == OpKind::Variable {
                if let Some(var_op) = op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
                {
                    if var_decls.contains_key(&var_op.xref) || var_usages.contains_key(&var_op.xref)
                    {
                        panic!(
                            "Should not see two declarations of the same variable: {}",
                            var_op.xref.as_usize()
                        );
                    }
                    var_decls.insert(var_op.xref, index);
                    var_usages.insert(var_op.xref, 0);
                }
            }

            op_map.insert(index, collect_op_info(op.as_ref()));
            count_variable_usages(op.as_ref(), &mut var_usages, &mut var_remote_usages, false);
        }

        // Second pass
        let mut context_is_used = false;
        let mut indices_to_remove: Vec<usize> = Vec::new();
        let mut indices_to_replace: Vec<(usize, Statement)> = Vec::new();

        for index in (0..ops.len()).rev() {
            let op = ops.get(index).unwrap();

            if op.kind() == OpKind::Variable {
                if let Some(var_op) = op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
                {
                    let usage_count = var_usages.get(&var_op.xref).copied().unwrap_or(0);

                    if usage_count == 0 && !var_remote_usages.contains(&var_op.xref) {
                        let op_info = op_map.get(&index).unwrap();
                        let keep_for_side_effects = (context_is_used
                            && op_info.fences.contains(Fence::VIEW_CONTEXT_WRITE))
                            || op_info.fences.contains(Fence::SIDE_EFFECTFUL);

                        if keep_for_side_effects {
                            let stmt = (*var_op.initializer).clone().to_stmt();
                            indices_to_replace.push((index, stmt));
                        } else {
                            indices_to_remove.push(index);
                            uncount_variable_usages(op.as_ref(), &mut var_usages);
                            op_map.swap_remove(&index);
                        }

                        var_decls.shift_remove(&var_op.xref);
                        var_usages.shift_remove(&var_op.xref);

                        did_change = true;
                        continue;
                    }
                }
            }

            if let Some(op_info) = op_map.get(&index) {
                if op_info.fences.contains(Fence::VIEW_CONTEXT_READ) {
                    context_is_used = true;
                }
            }
        }

        for (index, stmt) in indices_to_replace {
            let stmt_op =
                create_statement_op::<Box<dyn ir::UpdateOp + Send + Sync>>(Box::new(stmt));
            let op_info = op_map.shift_remove(&index).unwrap();
            ops.replace_at(index, Box::new(stmt_op));
            op_map.insert(index, op_info);
            did_change = true;
        }

        for &index in indices_to_remove.iter() {
            // Update var_decls indices because ops removal shifts indices
            for decl_idx in var_decls.values_mut() {
                if *decl_idx > index {
                    *decl_idx -= 1;
                }
            }
            ops.remove_at(index);
            let mut new_op_map = IndexMap::new();
            for (old_idx, info) in op_map {
                if old_idx > index {
                    new_op_map.insert(old_idx - 1, info);
                } else if old_idx != index {
                    new_op_map.insert(old_idx, info);
                }
            }
            op_map = new_op_map;

            for index_ref in var_decls.values_mut() {
                if *index_ref > index {
                    *index_ref -= 1;
                }
            }
        }

        // Third pass
        let mut to_inline: Vec<XrefId> = Vec::new();
        // Explicitly iterate in insertion order because vars_usages is now an IndexMap
        for (xref, &count) in &var_usages {
            if let Some(&decl_index) = var_decls.get(xref) {
                let decl_op = ops.get(decl_index).unwrap();

                if let Some(var_op) = decl_op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
                {
                    let is_always_inline = var_op.flags.contains(VariableFlags::ALWAYS_INLINE);
                    if count == 1 && !is_always_inline && !var_remote_usages.contains(xref) {
                        to_inline.push(*xref);
                    }
                }
            }
        }

        while let Some(candidate) = to_inline.pop() {
            let decl_index = *var_decls.get(&candidate).unwrap();

            let (initializer, is_always_inline, var_kind) = {
                let op = ops.get(decl_index).unwrap();
                if let Some(var_op) = op
                    .as_any()
                    .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
                {
                    (
                        (*var_op.initializer).clone(),
                        var_op.flags.contains(VariableFlags::ALWAYS_INLINE),
                        var_op.variable.kind(),
                    )
                } else {
                    panic!("Expected VariableOp");
                }
            };

            if is_always_inline {
                panic!("AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.");
            }

            let var_info = op_map.get(&decl_index).unwrap().clone();

            for target_index in (decl_index + 1)..ops.len() {
                let target_info_ref = op_map.get(&target_index).unwrap();
                if target_info_ref.variables_used.contains(&candidate) {
                    let mut allowed = true;
                    if compatibility == CompatibilityMode::TemplateDefinitionBuilder {
                        let target_op = ops.get(target_index).unwrap();
                        if !allow_conservative_inlining(&initializer, target_op.as_ref(), var_kind)
                        {
                            allowed = false;
                        }
                    }
                    if !allowed {
                        break;
                    }

                    let target_op_mut = ops.get_mut(target_index).unwrap();
                    if try_inline_variable_initializer(
                        candidate,
                        initializer.clone(),
                        target_op_mut.as_mut(),
                        var_info.fences.clone(),
                    ) {
                        let mut new_target_info = OpInfo {
                            variables_used: target_info_ref.variables_used.clone(),
                            fences: target_info_ref.fences,
                        };
                        new_target_info.variables_used.remove(&candidate);
                        for &var_xref in &var_info.variables_used {
                            new_target_info.variables_used.insert(var_xref);
                        }
                        new_target_info.fences |= var_info.fences.clone();
                        op_map.insert(target_index, new_target_info);

                        var_decls.shift_remove(&candidate);
                        var_usages.shift_remove(&candidate);

                        op_map.shift_remove(&decl_index);
                        ops.remove_at(decl_index);

                        let mut new_op_map = IndexMap::new();
                        for (old_idx, info) in op_map {
                            if old_idx > decl_index {
                                new_op_map.insert(old_idx - 1, info);
                            } else if old_idx != decl_index {
                                new_op_map.insert(old_idx, info);
                            }
                        }
                        op_map = new_op_map;

                        for index_ref in var_decls.values_mut() {
                            if *index_ref > decl_index {
                                *index_ref -= 1;
                            }
                        }

                        did_change = true;
                        break;
                    } else {
                        break;
                    }
                }

                if !safe_to_inline_past_fences(target_info_ref.fences, var_info.fences) {
                    break;
                }
            }
        }

        if !did_change {
            break;
        }
    }
}

/// Helper to visit expressions in an operation without needing mutable reference
/// Uses recursive pattern to traverse all expressions
fn visit_expressions_in_op_readonly(
    op: &dyn ir::Op,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    use crate::template::pipeline::ir::ops::create::*;
    use crate::template::pipeline::ir::ops::shared::*;
    use crate::template::pipeline::ir::ops::update::*;

    // helper to visit binding ops
    let visit_binding_op =
        |binding: &BindingOp, visitor: &mut dyn FnMut(&Expression, VisitorContextFlag), flags| {
            match &binding.expression {
                BindingExpression::Expression(expr) => {
                    visit_expressions_recursive(expr, visitor, flags)
                }
                BindingExpression::Interpolation(interp) => {
                    for expr in &interp.expressions {
                        visit_expressions_recursive(expr, visitor, flags);
                    }
                }
            }
        };

    match op.kind() {
        OpKind::Variable => {
            if let Some(var_op) = op
                .as_any()
                .downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>()
            {
                visit_expressions_recursive(&var_op.initializer, visitor, flags);
            } else if let Some(var_op) = op
                .as_any()
                .downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
            {
                visit_expressions_recursive(&var_op.initializer, visitor, flags);
            } else if let Some(var_op) = op
                .as_any()
                .downcast_ref::<VariableOp<Box<dyn ir::Op + Send + Sync>>>()
            {
                // Fallback for when we don't know the exact type but it matches Op
                visit_expressions_recursive(&var_op.initializer, visitor, flags);
            }
        }
        OpKind::Binding => {
            if let Some(binding) = op.as_any().downcast_ref::<BindingOp>() {
                visit_binding_op(binding, visitor, flags);
            }
        }
        OpKind::Property => {
            if let Some(prop) = op.as_any().downcast_ref::<PropertyOp>() {
                match &prop.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
                if let Some(ref s) = prop.sanitizer {
                    visit_expressions_recursive(s, visitor, flags);
                }
            }
        }
        OpKind::DomProperty => {
            if let Some(p) = op
                .as_any()
                .downcast_ref::<crate::template::pipeline::ir::ops::host::DomPropertyOp>()
            {
                match &p.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
                if let Some(ref s) = p.sanitizer {
                    visit_expressions_recursive(s, visitor, flags);
                }
            }
        }
        OpKind::Statement => {
            use crate::template::pipeline::ir::ops::StatementOp;
            // StatementOp is usually UpdateOp
            if let Some(stmt_op) = op
                .as_any()
                .downcast_ref::<StatementOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
            {
                visit_expressions_in_statement(&stmt_op.statement, visitor, flags);
            } else {
                // Try CreateOp?
                if let Some(stmt_op) = op
                    .as_any()
                    .downcast_ref::<StatementOp<Box<dyn ir::CreateOp + Send + Sync>>>()
                {
                    visit_expressions_in_statement(&stmt_op.statement, visitor, flags);
                }
            }
        }
        OpKind::Attribute => {
            if let Some(attr) = op.as_any().downcast_ref::<AttributeOp>() {
                match &attr.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
                if let Some(ref s) = attr.sanitizer {
                    visit_expressions_recursive(s, visitor, flags);
                }
            }
        }
        OpKind::Control => {
            if let Some(c) = op.as_any().downcast_ref::<ControlOp>() {
                match &c.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
                if let Some(ref s) = c.sanitizer {
                    visit_expressions_recursive(s, visitor, flags);
                }
            }
        }
        OpKind::StyleProp => {
            if let Some(p) = op.as_any().downcast_ref::<StylePropOp>() {
                match &p.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
            }
        }
        OpKind::ClassProp => {
            if let Some(p) = op.as_any().downcast_ref::<ClassPropOp>() {
                visit_expressions_recursive(&p.expression, visitor, flags);
            }
        }
        OpKind::StyleMap => {
            if let Some(p) = op.as_any().downcast_ref::<StyleMapOp>() {
                match &p.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
            }
        }
        OpKind::ClassMap => {
            if let Some(p) = op.as_any().downcast_ref::<ClassMapOp>() {
                match &p.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
            }
        }
        OpKind::InterpolateText => {
            if let Some(i) = op.as_any().downcast_ref::<InterpolateTextOp>() {
                for e in &i.interpolation.expressions {
                    visit_expressions_recursive(e, visitor, flags);
                }
            }
        }
        OpKind::Statement => {
            if let Some(stmt) = op
                .as_any()
                .downcast_ref::<StatementOp<Box<dyn ir::UpdateOp + Send + Sync>>>()
            {
                visit_expressions_in_statement(&stmt.statement, visitor, flags);
            } else if let Some(stmt) = op
                .as_any()
                .downcast_ref::<StatementOp<Box<dyn ir::CreateOp + Send + Sync>>>()
            {
                visit_expressions_in_statement(&stmt.statement, visitor, flags);
            }
        }
        OpKind::StoreLet => {
            if let Some(s) = op.as_any().downcast_ref::<StoreLetOp>() {
                visit_expressions_recursive(&s.value, visitor, flags);
            }
        }
        OpKind::I18nExpression => {
            if let Some(i) = op.as_any().downcast_ref::<I18nExpressionOp>() {
                visit_expressions_recursive(&i.expression, visitor, flags);
            }
        }
        OpKind::DeferWhen => {
            if let Some(d) = op.as_any().downcast_ref::<DeferWhenOp>() {
                visit_expressions_recursive(&d.expr, visitor, flags);
            }
        }
        OpKind::AnimationString => {
            if let Some(a) = op.as_any().downcast_ref::<AnimationStringOp>() {
                match &a.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
            }
        }
        OpKind::AnimationBinding => {
            if let Some(a) = op.as_any().downcast_ref::<AnimationBindingOp>() {
                match &a.expression {
                    BindingExpression::Expression(expr) => {
                        visit_expressions_recursive(expr, visitor, flags)
                    }
                    BindingExpression::Interpolation(interp) => {
                        for e in &interp.expressions {
                            visit_expressions_recursive(e, visitor, flags);
                        }
                    }
                }
            }
        }
        OpKind::Listener => {
            if let Some(listener) = op.as_any().downcast_ref::<ListenerOp>() {
                for handler_op in &listener.handler_ops {
                    visit_expressions_in_op_readonly(
                        handler_op.as_ref(),
                        visitor,
                        flags | VisitorContextFlag::IN_CHILD_OPERATION,
                    );
                }
            }
        }
        OpKind::AnimationListener => {
            if let Some(listener) = op.as_any().downcast_ref::<AnimationListenerOp>() {
                for handler_op in &listener.handler_ops {
                    visit_expressions_in_op_readonly(
                        handler_op.as_ref(),
                        visitor,
                        flags | VisitorContextFlag::IN_CHILD_OPERATION,
                    );
                }
            }
        }
        OpKind::TwoWayListener => {
            if let Some(listener) = op.as_any().downcast_ref::<TwoWayListenerOp>() {
                for handler_op in &listener.handler_ops {
                    visit_expressions_in_op_readonly(
                        handler_op.as_ref(),
                        visitor,
                        flags | VisitorContextFlag::IN_CHILD_OPERATION,
                    );
                }
            }
        }
        OpKind::TwoWayProperty => {
            if let Some(t) = op.as_any().downcast_ref::<TwoWayPropertyOp>() {
                visit_expressions_recursive(&t.expression, visitor, flags);
                if let Some(ref s) = t.sanitizer {
                    visit_expressions_recursive(s, visitor, flags);
                }
            }
        }
        OpKind::Conditional => {
            if let Some(c) = op.as_any().downcast_ref::<ConditionalOp>() {
                if let Some(ref test) = c.test {
                    visit_expressions_recursive(test, visitor, flags);
                }
                for case in &c.conditions {
                    if let Some(ref expr) = case.expr {
                        visit_expressions_recursive(expr, visitor, flags);
                    }
                }
                if let Some(ref p) = c.processed {
                    visit_expressions_recursive(p, visitor, flags);
                }
                if let Some(ref v) = c.context_value {
                    visit_expressions_recursive(v, visitor, flags);
                }
            }
        }
        OpKind::Repeater => {
            if let Some(r) = op.as_any().downcast_ref::<RepeaterOp>() {
                visit_expressions_recursive(&r.collection, visitor, flags);
            }
        }
        _ => {}
    }
}

/// Recursively visit all expressions in an expression
fn visit_expressions_recursive(
    expr: &Expression,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    visitor(expr, flags);
    use crate::output::output_ast::Expression as OutputExpr;
    match expr {
        OutputExpr::ReadVariable(read_var) => if read_var.xref.0 == 134 {},
        OutputExpr::BinaryOp(bin) => {
            visit_expressions_recursive(&bin.lhs, visitor, flags);
            visit_expressions_recursive(&bin.rhs, visitor, flags);
        }
        OutputExpr::Unary(un) => {
            visit_expressions_recursive(&un.expr, visitor, flags);
        }
        OutputExpr::ReadProp(prop) => {
            visit_expressions_recursive(&prop.receiver, visitor, flags);
        }
        OutputExpr::ReadKey(key) => {
            visit_expressions_recursive(&key.receiver, visitor, flags);
            visit_expressions_recursive(&key.index, visitor, flags);
        }
        OutputExpr::InvokeFn(invoke) => {
            visit_expressions_recursive(&invoke.fn_, visitor, flags);
            for arg in &invoke.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        OutputExpr::LiteralArray(arr) => {
            for entry in &arr.entries {
                visit_expressions_recursive(entry, visitor, flags);
            }
        }
        OutputExpr::LiteralMap(map) => {
            for entry in &map.entries {
                visit_expressions_recursive(&entry.value, visitor, flags);
            }
        }
        OutputExpr::Conditional(cond) => {
            visit_expressions_recursive(&cond.condition, visitor, flags);
            visit_expressions_recursive(&cond.true_case, visitor, flags);
            if let Some(ref false_case) = cond.false_case {
                visit_expressions_recursive(false_case, visitor, flags);
            }
        }
        OutputExpr::SafePropertyRead(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
        }
        OutputExpr::SafeKeyedRead(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
            visit_expressions_recursive(&ir_expr.index, visitor, flags);
        }
        OutputExpr::SafeInvokeFunction(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
            for arg in &ir_expr.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        OutputExpr::SafeTernary(ir_expr) => {
            visit_expressions_recursive(&ir_expr.guard, visitor, flags);
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::PipeBinding(ir_expr) => {
            for arg in &ir_expr.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        OutputExpr::PipeBindingVariadic(ir_expr) => {
            visit_expressions_recursive(&ir_expr.args, visitor, flags);
        }
        OutputExpr::AssignTemporary(ir_expr) => {
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::StoreLet(ir_expr) => {
            visit_expressions_recursive(&ir_expr.value, visitor, flags);
        }
        OutputExpr::ConditionalCase(ir_expr) => {
            if let Some(ref expr) = ir_expr.expr {
                visit_expressions_recursive(expr, visitor, flags);
            }
        }
        OutputExpr::ResetView(ir_expr) => {
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::RestoreView(ir_expr) => {
            if let ir::expression::EitherXrefIdOrExpression::Expression(expr) = &ir_expr.view {
                visit_expressions_recursive(expr, visitor, flags);
            }
        }
        OutputExpr::ArrowFn(ir_expr) => {
            if let crate::output::output_ast::ArrowFunctionBody::Expression(ref expr) = ir_expr.body
            {
                visit_expressions_recursive(expr, visitor, flags);
            }
        }
        OutputExpr::PureFunction(ir_expr) => {
            if let Some(ref fn_) = ir_expr.fn_ {
                visit_expressions_recursive(fn_, visitor, flags);
            }
            if let Some(ref body) = ir_expr.body {
                visit_expressions_recursive(body, visitor, flags);
            }
            for arg in &ir_expr.args {
                visit_expressions_recursive(arg, visitor, flags);
            }
        }
        _ => {}
    }
}

/// Visit expressions in a statement
fn visit_expressions_in_statement(
    stmt: &Statement,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    use crate::output::output_ast::Statement;
    match stmt {
        Statement::Expression(expr_stmt) => {
            visit_expressions_recursive(&expr_stmt.expr, visitor, flags);
        }
        Statement::Return(return_stmt) => {
            visit_expressions_recursive(&return_stmt.value, visitor, flags);
        }
        Statement::DeclareVar(declare_var) => {
            if let Some(ref value) = declare_var.value {
                visit_expressions_recursive(value, visitor, flags);
            }
        }
        Statement::IfStmt(if_stmt) => {
            visit_expressions_recursive(&if_stmt.condition, visitor, flags);
            for case_stmt in &if_stmt.true_case {
                visit_expressions_in_statement(case_stmt, visitor, flags);
            }
            for case_stmt in &if_stmt.false_case {
                visit_expressions_in_statement(case_stmt, visitor, flags);
            }
        }
        Statement::DeclareFn(declare_fn) => {
            for stmt in &declare_fn.statements {
                visit_expressions_in_statement(stmt, visitor, flags);
            }
        }
    }
}

/// Build the `OpInfo` structure for the given `op`.
fn collect_op_info(op: &dyn ir::Op) -> OpInfo {
    let mut fences = Fence::NONE;
    let mut variables_used = HashSet::new();

    // Use read-only visitor to collect info
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, _flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    match ir_expr {
                        ir::IRExpression::ReadVariable(read_var) => {
                            variables_used.insert(read_var.xref);
                        }
                        ir::IRExpression::RestoreView(ref restore) => {
                            if let ir::expression::EitherXrefIdOrExpression::XrefId(xref) =
                                restore.view
                            {
                                variables_used.insert(xref);
                            }
                            fences |= fences_for_ir_expression(&ir_expr);
                        }
                        _ => {
                            fences |= fences_for_ir_expression(&ir_expr);
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );

    OpInfo {
        variables_used,
        fences,
    }
}

/// Count the number of usages of each variable, being careful to track whether those usages are
/// local or remote.
fn count_variable_usages(
    op: &dyn ir::Op,
    var_usages: &mut IndexMap<XrefId, usize>,
    var_remote_usage: &mut HashSet<XrefId>,
    is_remote_context: bool,
) {
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, flags| {
            // 1. Handle regular ReadVariable usage
            // 1. Handle regular ReadVariable usage
            if let Expression::ReadVariable(read_var) = expr {
                *var_usages.entry(read_var.xref).or_insert(0) += 1;

                // If we are in a child operation (like a listener) or if is_remote_context is set,
                // we must mark this variable as having remote usage, even if it's not declared
                // in the current list being optimized.
                if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION) || is_remote_context {
                    var_remote_usage.insert(read_var.xref);
                }
            }

            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    match ir_expr {
                        ir::IRExpression::ReadVariable(read_var) => {
                            if let Some(count) = var_usages.get_mut(&read_var.xref) {
                                *count += 1;
                            }

                            if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION)
                                || is_remote_context
                            {
                                var_remote_usage.insert(read_var.xref);
                            }
                        }
                        ir::IRExpression::RestoreView(ref restore) => {
                            match &restore.view {
                                ir::expression::EitherXrefIdOrExpression::XrefId(xref) => {
                                    if let Some(count) = var_usages.get_mut(xref) {
                                        *count += 1;
                                    }
                                    if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION)
                                        || is_remote_context
                                    {
                                        var_remote_usage.insert(*xref);
                                    }
                                }
                                ir::expression::EitherXrefIdOrExpression::Expression(_) => {
                                    // visit_expressions_recursive will handle the nested expression.
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
}

/// Remove usages of a variable in `op` from the `var_usages` tracking.
fn uncount_variable_usages(op: &dyn ir::Op, var_usages: &mut IndexMap<XrefId, usize>) {
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, _flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    match ir_expr {
                        ir::IRExpression::ReadVariable(read_var) => {
                            if let Some(count) = var_usages.get_mut(&read_var.xref) {
                                if *count == 0 {
                                    panic!(
                                        "Inaccurate variable count: {} - found another read but count is already 0",
                                        read_var.xref.as_usize()
                                    );
                                }
                                *count -= 1;
                            }
                        }
                        ir::IRExpression::RestoreView(ref restore) => {
                            if let ir::expression::EitherXrefIdOrExpression::XrefId(xref) =
                                restore.view
                            {
                                if let Some(count) = var_usages.get_mut(&xref) {
                                    if *count == 0 {
                                        panic!(
                                            "Inaccurate variable count for view xref: {} - found another restore but count is already 0",
                                            xref.as_usize()
                                        );
                                    }
                                    *count -= 1;
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
}

/// Checks whether it's safe to inline a variable across a particular operation.
fn safe_to_inline_past_fences(fences: Fence, decl_fences: Fence) -> bool {
    if fences.contains(Fence::VIEW_CONTEXT_WRITE) {
        if decl_fences.contains(Fence::VIEW_CONTEXT_READ) {
            return false;
        }
    } else if fences.contains(Fence::VIEW_CONTEXT_READ) {
        if decl_fences.contains(Fence::VIEW_CONTEXT_WRITE) {
            return false;
        }
    }
    true
}

/// Attempt to inline the initializer of a variable into a target operation's expressions.
fn try_inline_variable_initializer(
    id: XrefId,
    initializer: Expression,
    target: &mut dyn ir::Op,
    decl_fences: Fence,
) -> bool {
    let mut inlined = false;
    let mut inlining_allowed = true;

    transform_expressions_in_op(
        target,
        &mut |expr: Expression, flags| {
            if inlined || !inlining_allowed {
                return expr;
            }

            if !is_ir_expression(&expr) {
                return expr;
            }

            if let Some(ir_expr) = as_ir_expression(&expr) {
                if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION)
                    && decl_fences.contains(Fence::VIEW_CONTEXT_READ)
                {
                    // Cannot inline context-sensitive variables across operation boundaries
                    return expr;
                }

                match ir_expr {
                    ir::IRExpression::ReadVariable(read_var) => {
                        if read_var.xref == id {
                            // This is the usage site - inline it
                            inlined = true;
                            return initializer.clone();
                        }
                    }
                    _ => {
                        // Check fences for this expression
                        let expr_fences = fences_for_ir_expression(&ir_expr);
                        inlining_allowed = inlining_allowed
                            && safe_to_inline_past_fences(expr_fences, decl_fences);
                    }
                }
            }

            expr
        },
        VisitorContextFlag::NONE,
    );

    inlined
}

/// Safe alternative to check conservative inlining without requiring generic VariableOp
/// Safe check for conservative inlining that matches TS logic
fn allow_conservative_inlining(
    initializer: &Expression,
    target: &dyn ir::Op,
    variable_kind: SemanticVariableKind,
) -> bool {
    match variable_kind {
        SemanticVariableKind::Identifier => {
            if let Expression::ReadVar(read_var) = initializer {
                if read_var.name == "ctx" {
                    return true;
                }
            }
            false
        }
        SemanticVariableKind::Context => target.kind() == OpKind::Variable,
        _ => true,
    }
}

/// Given an `ir.Expression`, returns the `Fence` flags for that expression type.
fn fences_for_ir_expression(expr: &ir::IRExpression) -> Fence {
    match expr {
        ir::IRExpression::NextContext(_) => {
            // NextContext reads/writes context.
            Fence::VIEW_CONTEXT_READ | Fence::VIEW_CONTEXT_WRITE
        }
        ir::IRExpression::RestoreView(_) => {
            Fence::VIEW_CONTEXT_READ | Fence::VIEW_CONTEXT_WRITE | Fence::SIDE_EFFECTFUL
        }
        ir::IRExpression::GetCurrentView(_) => Fence::NONE,
        ir::IRExpression::StoreLet(_) => Fence::SIDE_EFFECTFUL,
        ir::IRExpression::Reference(_) | ir::IRExpression::ContextLetReference(_) => {
            Fence::VIEW_CONTEXT_READ
        }
        _ => Fence::NONE,
    }
}
